from pyquaternion import Quaternion
import numpy as np
from astropy.time import Time
import astropy.units as u

from targets import SolarSystemTarget

def get_net_power(
    q_attitude, earth_satellite, time, solar_panel_normals, solar_panel_areas, 
    solar_panel_eff, power_load
):
    """
    Determine whether the current satellite attitude results in a power surplus 
    or a power deficit by calculating the net power generated by the solar arrays.

    Parameters
    ----------
    q_attitude : Quaternion object
        A quaternion representing the current spacecraft attitude. 
        It rotates a vector from the ECI frame to the body frame.

    earth_satellite : skyfield.sgp4lib.EarthSatellite
        The Skyfield EarthSatellite object representing the satellite in operation.

    time : astropy.time.Time
        The observation time, used to determine the Sun's position 
        relative to the satellite.

    solar_panel_normals : list of numpy.ndarray
        A list of unit vectors representing the normal directions of the solar arrays in
        the body frame.

    solar_panel_areas : numpy.ndarray
        A 1D array representing the area (in m²) of each solar array, corresponding to 
        `solar_panel_normals`.

    solar_panel_eff : float
        End-of-life (EOL) efficiency of the solar panels, expressed as a decimal.

    power_load : float
        The orbit-average power consumption (in Watts).

    Returns
    -------
    net_power : float
        The net power (in Watts), calculated as the power generated minus the power 
        consumed. A positive value indicates a power surplus, while a negative value 
        indicates a power deficit.
    """
    # Define the Sun direction vector in the ECI frame
    sun_direction_eci = SolarSystemTarget('sun').pointing(earth_satellite, time)

    # Rotate the Sun direction vector from the ECI frame to the body frame
    sun_direction_body = (
        q_attitude.inverse * Quaternion(scalar=0, vector=sun_direction_eci) * q_attitude
    ).vector

    # Compute the cosine of the angle between the Sun vector and each solar panel normal
    # Set values to zero for panels facing away from the Sun
    panel_cosines = np.dot(solar_panel_normals, sun_direction_body)
    panel_cosines[panel_cosines < 0] = 0

    # Calculate the total power input (in Watts) from all solar arrays
    solar_flux = 1367  # Solar constant in W/m²
    panel_power_input = np.sum(
        solar_flux * solar_panel_eff * solar_panel_areas * panel_cosines
    )
    # print(f"The total power input from solar arrays is {panel_power_input:.0f} W.")

    # Determine the net power
    net_power = panel_power_input - power_load
    
    return net_power


def update_battery(
    battery_level, battery_tracker, Now, duration, net_power, battery_cap, battery_dod
):
    """
    Updates the battery's energy level based on the net power generated over a given 
    duration. If the net power is positive, the battery is charged; if negative, the 
    battery is discharged. And documents the battery level before and after the update
    in `battery_tracker`.

    Parameters
    ----------
    battery_level : float
        The current energy level (in Watt-hours) of the battery.

    battery_tracker : dict
        A tracker that records the onboard battery energy level (in W-hr) over time.
        Formatted as {"time": [], "energy_level": []}.

    Now : astropy.time.Time
        The current time.
    
    duration : float
        The time (in seconds) over which the net power is applied.

    net_power : float
        The net power (in Watts) generated by the solar arrays.

    battery_cap : float
        The total energy capacity (in Watt-hours) of the battery. 

    battery_dod : float
         The allowable depth-of-discharge limit for the battery, expressed as a decimal 
         fraction of its total capacity.

    Returns
    -------
    battery_level : float
        The updated energy level (in Watt-hours) of the battery.

    Raises
    ------
    ValueError
        If the battery discharge exceeds the depth-of-discharge limit.
    """
    # Document the current battery energy level
    battery_tracker["time"].append(Now.iso)
    battery_tracker["energy_level"].append(battery_level)
    
    # Update the battery energy level (W-hr)
    battery_level += net_power * (duration / 3600)

    # Cannot recharge over the battery capacity
    if battery_level > battery_cap:
        battery_level = battery_cap

    # Check if the battery energy discharge is greater than the DoD limit
    current_dod = (battery_cap - battery_level) / battery_cap
    if current_dod > battery_dod:
        raise ValueError(
            f"Battery discharged {(current_dod * 100):.0f} %, "
            "exceeding the maximum depth of discharge. "
            "Operation halted to prevent battery damage."
        )

    # Document the updated battery energy level
    battery_tracker["time"].append((Now + duration * u.s).iso)
    battery_tracker["energy_level"].append(battery_level)

    return battery_level